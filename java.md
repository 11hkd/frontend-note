# 后端八股-JAVA

### 重载和重写的区别

**重载**：在同一个类中，允许存在多个同名方法，只要它们的参数列表不同（参数个数、参数类型、参数顺序不同），与返回值类型和访问修饰符无关。

**重写**：发生在子类和父类之间，子类中定义了与父类中同名同参数列表的方法，并且返回值类型和异常类型也要和父类保持一致或者是父类返回值类型的子类，访问修饰符的限制要小于等于父类的访问修饰符。

### String 和 StringBuffer、StringBuilder 的区别

**String**、**StringBuffer** 和 **StringBuilder** 都是 Java 中用于处理字符串的类，它们之间存在以下区别：

#### 可变性

- **String**：不可变的字符序列。一旦创建，其内容就不能被改变。对 `String` 对象进行的任何修改操作，实际上都会创建一个新的 `String` 对象来存储修改后的结果，而原始的 `String` 对象保持不变。
- **StringBuffer**：可变的字符序列。可以通过调用其各种方法来直接修改对象内部存储的字符序列，而无需创建新的对象。
- **StringBuilder**：可变的字符序列，与 `StringBuffer` 类似，但在单线程环境下具有更好的性能表现，因为它的方法没有被 `synchronized` 关键字修饰，不需要进行同步处理，执行效率相对较高。

#### 线程安全性

- **String**：由于其不可变性，因此是线程安全的。多个线程可以同时访问同一个 `String` 对象，而不会导致数据不一致的问题。
- **StringBuffer**：线程安全的类，其内部的大多数方法都使用了 `synchronized` 关键字进行修饰，保证了在多线程环境下对同一个 `StringBuffer` 对象进行操作时的线程安全性。
- **StringBuilder**：非线程安全的类，在多线程环境下如果多个线程同时访问和修改同一个 `StringBuilder` 对象，可能会导致数据不一致或其他并发问题。

### String 不可变的原因

- **安全性**：字符串在许多应用中被广泛用于表示不可变的数据，如文件名、URL、密码等。如果 `String` 是可变的，那么这些重要的数据就可能会被意外或恶意地修改，从而导致安全漏洞。
- **哈希码的一致性**：`String` 类重写了 `hashCode()` 方法，其哈希码是根据字符串的内容计算得出的。如果 `String` 是可变的，那么当字符串的内容发生变化时，其哈希码也会改变，这将导致在使用哈希表存储和查找 `String` 对象时出现问题，例如无法正确地获取和更新与该字符串相关联的值。
- **字符串常量池的优化**：Java 中的字符串常量池是为了提高字符串的使用效率和节省内存空间而设计的。由于 `String` 是不可变的，相同内容的字符串可以在常量池中共享，避免了重复创建相同字符串对象的开销。如果 `String` 是可变的，那么字符串常量池的这种优化机制将无法实现，因为一个字符串对象的内容可能会随时改变，无法保证其在常量池中的唯一性和一致性。
- **线程安全**：不可变性使得 `String` 对象在多线程环境下可以安全地共享，无需额外的同步操作，从而提高了程序的性能和并发处理能力。

综上所述，`String`、`StringBuffer` 和 `StringBuilder` 各有特点，在实际使用中应根据具体的需求和场景来选择合适的类来处理字符串，以达到最佳的性能和功能要求。

### 自动装箱与自动拆箱

**自动装箱**：Java 自动将基本数据类型转换为对应的包装类型的过程。例如，将 `int` 类型的变量自动转换为 `Integer` 类型的对象。

**自动拆箱**：Java 自动将包装类型转换为对应的基本数据类型的过程。例如，将 `Integer` 类型的对象自动转换为 `int` 类型的值。

#### 注意事项

- **性能问题**：虽然自动装箱和拆箱为编程带来了便利，但在一些性能敏感的场景中需要注意其性能开销。因为自动装箱和拆箱实际上是通过调用包装类型的 `valueOf()` 方法和相应的 `xxxValue()` 方法来实现的，频繁的装箱和拆箱操作可能会影响程序的性能。
- **空指针异常**：在使用自动拆箱时，如果包装类型的对象为 `null`，则会抛出 `NullPointerException`。因此，在进行自动拆箱操作之前，需要确保包装类型的对象不为 `null`。
- **缓存机制**：对于 `Byte`、`Short`、`Integer`、`Long` 这几种包装类型，它们都有缓存机制。在一定范围内的值会被缓存起来，当自动装箱时，如果值在缓存范围内，会直接返回缓存中的对象，而不是创建新的对象。例如，`Integer` 的缓存范围是 -128 到 127，当自动装箱的值在这个范围内时，会使用缓存中的 `Integer` 对象。

### == 和 equals 的区别

==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 
==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较
==指引用是否相同， equals()指的是值是否相同

### Object 类中的方法

1. **toString()**：返回该对象的字符串表示。
2. **hashCode()**：返回该对象的哈希码。
3. **getClass()**：通过调用该对象的 `getClass()` 方法，可以得到这个对象所属的类的相关信息，包括类的名称、父类、实现的接口、类中定义的方法和字段等。
4. **clone()**：克隆出一个对象，属性参数完全相同，除了地址。
5. **finalize()**：垃圾回收机制。
6. **wait()**：暂缓线程的执行。
7. **notify()**：唤醒一个正在等待的线程，加一个 `all` 就是唤醒等待的所有线程。

### 异常处理

Java 中的异常分为两大类，即 `Error` 和 `Exception`。

- **Error**：表示严重的错误，通常是由 Java 虚拟机内部的错误或资源耗尽等问题引起的，一般无法恢复，程序通常会终止运行。
- **Exception**：一般性的异常，可以分为运行时异常（`RuntimeException`）和非运行时异常（受检异常，`Checked Exception`）。

### 获取键盘输入

1. 引入 `Scanner` 类：`Scanner` 类位于 `java.util` 包中，因此需要在代码开头引入该包：`import java.util.Scanner;`
2. 创建 `Scanner` 对象：在需要获取键盘输入的地方，创建 `Scanner` 类的实例，它可以接收来自标准输入流（通常是键盘）的输入。例如：`Scanner scanner = new Scanner(System.in);`
3. 获取不同类型的输入：通过 `Scanner` 类提供的各种方法，可以获取不同类型的输入值。例如，使用 `nextInt()` 方法获取整数输入，`nextDouble()` 方法获取双精度浮点数输入，`next()` 方法获取字符串输入等。

### 抽象类与接口

- **抽象类**：一个类只能继承一个抽象类，使用 `extends` 关键字实现继承。如果子类不是抽象类，则必须实现抽象类中的所有抽象方法。
- **接口**：一个类可以实现多个接口，使用 `implements` 关键字实现接口。实现类必须实现接口中的所有抽象方法。

### Java的垃圾回收机制

Java的垃圾回收机制是JVM（Java虚拟机）自动内存管理的一部分。它通过GC（Garbage Collection）守护进程在后台运行，主要负责识别和回收不再使用的对象，以防止内存泄漏和内存溢出。

垃圾回收是一个低优先级的进程，其优先级会根据内存使用情况动态调整，因此垃圾回收的执行时间是不确定的。这种设计是为了避免频繁的垃圾回收对程序性能造成影响，因为垃圾回收本身也会消耗CPU资源。

垃圾回收主要针对堆空间和方法区进行管理。

### 序列化是什么？
序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象。

### 缓存穿透
缓存穿透指缓存和数据库均没有需要查询的数据，攻击者不断发送这种请求，使数据库压力过大。

### 缓存击穿
缓存击穿指缓存中没有数据，但数据库中有该数据。一般这种情况指特定数据的缓存时间到期，但由于并发用户访问该数据特别多，因此去数据库去取数据，引起数据库访问压力过大

### 分布式

一个系统，各个组件分别部署在不同服务器，彼此通过网络通信和协调的系统

### 分布式系统和 微服务系统的区别
微服务可以多个组件可以部署在一个服务器，分部署侧重一个系统部署的方式，微服务是一种系统的架构。

### JKD1.8新特性
